# 第四届阿里中间件性能挑战赛复赛

### 1 前言

这个复赛我们非常卖力，算是较早一批JAVA跑的很好的选手，曾经都第6过，奈何我们有些机制一直没有理解到位，一些并发上的小技巧也十分欠缺，一直停滞不前最后21名。这个代码大家可以借鉴思想，具体磁盘NIO的一些操作做的并不是很专业。这点后面在做PolarDB比赛的时候，我们经过进一步的学习，我们做的很好啦，大家可以再看一下我们PolarDB初赛JAVA的代码。

这道题目有几个非常重要的点：

- 4G内存
- 100w个队列
- 每个队列2000条消息左右
- 每条消息50字节左右
- 总数据量100G左右

要求重写两个函数

```java
put(String queueName, byte[] message)；
Collection<byte[]> get(String queueName, long offset, long num)；
```

test/文件中，是本地测试文件，可直接运行测试

[题目链接](https://code.aliyun.com/middlewarerace2018/queuerace2018?spm=5176.12281978.0.0.88f754aby2nDIk)

------

### 2 结构

1. 由于内存远远无法容下所有消息（20亿个）的索引，故采取了稀疏索引，内存维护两个关键的Hash表：

   ​	key-队列名，value-每20条消息在文件中的位置

   ​	key-队列名，value-20条消息的缓存

2. 首先，每来一个消息我都先放到第二个hashmap中，每次我都检查放完之后，这个队列当前内存是否缓存够了20条。如果到了20条，我们就会刷盘，并且把这20条消息的起始位置放入第一个hashmap中。刷盘的时候，每条消息都要用一个字节来存这条消息的长度。
3. 一共100个G的数据，为了减小索引大小，让它在int这么大，所以我们开很多2G的文件用来存储消息。当然是根据队列名字%文件数量来判断这个队列的消息在哪个文件中。
4. 读的时候很简单，首先判断在哪个文件中，然后去第一个队列中取出这条消息所在的20个消息的索引，然后就去文件里找啦。

------

### 3 总结

这个代码主要是想法比较直接，具体的IO操作做的真的不怎么样。想看操作的话，看看PolarDB大赛的代码